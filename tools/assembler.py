"""Assembler for Another World VM bytecode.

The assembler consumes the round-trip friendly assembly format generated by
``disassembler.py`` and produces a byte-for-byte identical binary when no
edits were made.  It performs two passes: the first collects label addresses,
the second emits opcode bytes with all label references resolved.
"""

from __future__ import annotations

import argparse
import logging
import re
from pathlib import Path
from typing import Dict, List, Tuple

from common import format_label, resolve_label
from opcodes import (
    OP_SETI,
    OP_SETR,
    OP_ADDR,
    OP_ADDI,
    OP_CALL,
    OP_RET,
    OP_YIELD,
    OP_JUMP,
    OP_START,
    OP_DBRA,
    OP_CJMP,
    OP_FADE,
    OP_RESET,
    OP_PAGE,
    OP_FILL,
    OP_COPY,
    OP_SHOW,
    OP_HALT,
    OP_PRINT,
    OP_SUBR,
    OP_ANDI,
    OP_IORI,
    OP_LSLI,
    OP_LSRI,
    OP_SOUND,
    OP_LOAD,
    OP_MUSIC,
)


TOKEN_RE = re.compile(r"[,\s]+")


class AssemblyError(RuntimeError):
    pass


def _parse_line(line: str) -> Tuple[str | None, List[str]]:
    line = line.split(";", 1)[0].strip()
    if not line:
        return None, []

    label = None
    if line.endswith(":"):
        label = line[:-1]
        return label, []

    if ":" in line:
        label, rest = line.split(":", 1)
        label = label.strip()
        line = rest.strip()

    tokens = [token for token in TOKEN_RE.split(line) if token]
    return label, tokens


def _parse_assembly(lines: List[str]) -> Tuple[Dict[str, int], List[Tuple[int, List[str]]]]:
    labels: Dict[str, int] = {}
    instructions: List[Tuple[int, List[str]]] = []
    pc = 0

    for line in lines:
        label, tokens = _parse_line(line)
        if label:
            if label in labels:
                raise AssemblyError(f"duplicate label: {label}")
            labels[label] = pc
        if not tokens:
            continue
        opcode = tokens[0].upper()
        length = _estimate_length(opcode, tokens[1:])
        instructions.append((pc, tokens))
        pc += length

    return labels, instructions


def _estimate_length(opcode: str, operands: List[str]) -> int:
    if opcode == "CJMP":
        if operands[1].startswith("[$") and operands[2].startswith("[$"):
            return 6
        if operands[2].startswith("0x") and len(operands[2]) > 4:
            return 7
        return 6
    if opcode == "DB":
        return 1
    lengths = {
        "SETI": 4,
        "SETR": 3,
        "ADDR": 3,
        "ADDI": 4,
        "SUBR": 3,
        "ANDI": 4,
        "IORI": 4,
        "LSLI": 4,
        "LSRI": 4,
        "CALL": 3,
        "RET": 1,
        "YIELD": 1,
        "JUMP": 3,
        "START": 4,
        "DBRA": 4,
        "FADE": 3,
        "RESET": 4,
        "PAGE": 2,
        "FILL": 3,
        "COPY": 3,
        "SHOW": 2,
        "HALT": 1,
        "PRINT": 6,
        "SOUND": 6,
        "LOAD": 3,
        "MUSIC": 7,
        "DB": 1,
        "POLYRAW": None,
    }
    if opcode in lengths:
        length = lengths[opcode]
        if length is not None:
            return length
        count = 0
        for operand in operands:
            if operand == ';' or operand.startswith(';'):
                break
            count += 1
        return count
    raise AssemblyError(f"unsupported opcode: {opcode}")


def _parse_register(token: str) -> int:
    if not token.startswith("[$") or not token.endswith("]"):
        raise AssemblyError(f"invalid register operand: {token}")
    return int(token[2:-1], 16)


def _parse_u8(token: str, labels: Dict[str, int]) -> int:
    value = resolve_label(token, labels)
    return value & 0xFF


def _parse_u16(token: str, labels: Dict[str, int]) -> int:
    value = resolve_label(token, labels)
    return value & 0xFFFF


def _encode_poly1(tokens: List[str], labels: Dict[str, int]) -> bytes:
    if len(tokens) < 3:
        raise AssemblyError("POLY1 requires byte operands")
    result = bytearray()
    for token in tokens[1:]:
        if token == ';':
            break
        if token.startswith(';'):
            break
        result.append(_parse_u8(token, labels))
    return bytes(result)


def _encode_poly2(tokens: List[str], labels: Dict[str, int]) -> bytes:
    if len(tokens) < 5:
        raise AssemblyError("POLY2 requires byte operands")
    result = bytearray()
    for token in tokens[1:]:
        if token == ';':
            break
        if token.startswith(';'):
            break
        result.append(_parse_u8(token, labels))
    return bytes(result)


def _encode_instruction(tokens: List[str], labels: Dict[str, int]) -> bytes:
    opcode = tokens[0].upper()
    out = bytearray()

    def emit_u16(value: int) -> None:
        out.append((value >> 8) & 0xFF)
        out.append(value & 0xFF)

    if opcode == "SETI":
        out.append(OP_SETI)
        out.append(_parse_register(tokens[1]))
        emit_u16(_parse_u16(tokens[2], labels))
    elif opcode == "SETR":
        out.append(OP_SETR)
        out.append(_parse_register(tokens[1]))
        out.append(_parse_register(tokens[2]))
    elif opcode == "ADDR":
        out.append(OP_ADDR)
        out.append(_parse_register(tokens[1]))
        out.append(_parse_register(tokens[2]))
    elif opcode == "ADDI":
        out.append(OP_ADDI)
        out.append(_parse_register(tokens[1]))
        emit_u16(_parse_u16(tokens[2], labels))
    elif opcode == "CALL":
        out.append(OP_CALL)
        emit_u16(_parse_u16(tokens[1], labels))
    elif opcode == "RET":
        out.append(OP_RET)
    elif opcode == "YIELD":
        out.append(OP_YIELD)
    elif opcode == "JUMP":
        out.append(OP_JUMP)
        emit_u16(_parse_u16(tokens[1], labels))
    elif opcode == "START":
        out.append(OP_START)
        out.append(_parse_u8(tokens[1], labels))
        emit_u16(_parse_u16(tokens[2], labels))
    elif opcode == "DBRA":
        out.append(OP_DBRA)
        out.append(_parse_register(tokens[1]))
        emit_u16(_parse_u16(tokens[2], labels))
    elif opcode == "CJMP":
        out.append(OP_CJMP)
        cond_token = tokens[1].rstrip(",")
        cond_lookup = cond_token.lower()
        cond = CONDITION_MAP.get(cond_lookup)
        if cond is None:
            cond = int(cond_token, 16)
        reg1 = _parse_register(tokens[2])
        operand = tokens[3]
        variant = cond
        if operand.startswith("[$"):
            variant |= 0x80
        elif operand.startswith("0x") and len(operand) > 4:
            variant |= 0x40
        out.append(variant)
        out.append(reg1)
        operand = tokens[3]
        if operand.startswith("[$"):
            out.append(_parse_register(operand))
            emit_u16(_parse_u16(tokens[4], labels))
        elif operand.startswith("0x") and len(operand) > 4:
            emit_u16(_parse_u16(operand, labels))
            emit_u16(_parse_u16(tokens[4], labels))
        else:
            imm = _parse_u8(operand, labels)
            out.append(imm)
            emit_u16(_parse_u16(tokens[4], labels))
    elif opcode == "FADE":
        out.append(OP_FADE)
        emit_u16(_parse_u16(tokens[1], labels))
    elif opcode == "RESET":
        out.append(OP_RESET)
        out.append(_parse_u8(tokens[1], labels))
        out.append(_parse_u8(tokens[2], labels))
        out.append(_parse_u8(tokens[3], labels))
    elif opcode == "PAGE":
        out.append(OP_PAGE)
        out.append(_parse_u8(tokens[1], labels))
    elif opcode == "FILL":
        out.append(OP_FILL)
        out.append(_parse_u8(tokens[1], labels))
        out.append(_parse_u8(tokens[2], labels))
    elif opcode == "COPY":
        out.append(OP_COPY)
        out.append(_parse_u8(tokens[1], labels))
        out.append(_parse_u8(tokens[2], labels))
    elif opcode == "SHOW":
        out.append(OP_SHOW)
        out.append(_parse_u8(tokens[1], labels))
    elif opcode == "HALT":
        out.append(OP_HALT)
    elif opcode == "PRINT":
        out.append(OP_PRINT)
        emit_u16(_parse_u16(tokens[1], labels))
        out.append(_parse_u8(tokens[2], labels))
        out.append(_parse_u8(tokens[3], labels))
        out.append(_parse_u8(tokens[4], labels))
    elif opcode == "SUBR":
        out.append(OP_SUBR)
        out.append(_parse_register(tokens[1]))
        out.append(_parse_register(tokens[2]))
    elif opcode == "ANDI":
        out.append(OP_ANDI)
        out.append(_parse_register(tokens[1]))
        emit_u16(_parse_u16(tokens[2], labels))
    elif opcode == "IORI":
        out.append(OP_IORI)
        out.append(_parse_register(tokens[1]))
        emit_u16(_parse_u16(tokens[2], labels))
    elif opcode == "LSLI":
        out.append(OP_LSLI)
        out.append(_parse_register(tokens[1]))
        emit_u16(_parse_u16(tokens[2], labels))
    elif opcode == "LSRI":
        out.append(OP_LSRI)
        out.append(_parse_register(tokens[1]))
        emit_u16(_parse_u16(tokens[2], labels))
    elif opcode == "SOUND":
        out.append(OP_SOUND)
        emit_u16(_parse_u16(tokens[1], labels))
        out.append(_parse_u8(tokens[2], labels))
        out.append(_parse_u8(tokens[3], labels))
        out.append(_parse_u8(tokens[4], labels))
    elif opcode == "LOAD":
        out.append(OP_LOAD)
        emit_u16(_parse_u16(tokens[1], labels))
    elif opcode == "MUSIC":
        out.append(OP_MUSIC)
        out.append(_parse_u8(tokens[1], labels))
        emit_u16(_parse_u16(tokens[2], labels))
        emit_u16(_parse_u16(tokens[3], labels))
        out.append(_parse_u8(tokens[4], labels))
    elif opcode == "POLYRAW":
        for token in tokens[1:]:
            if token == ';' or token.startswith(';'):
                break
            out.append(_parse_u8(token, labels))
    elif opcode == "DB":
        value = _parse_u8(tokens[1], labels)
        out.append(value)
    else:
        raise AssemblyError(f"unsupported opcode: {opcode}")

    return bytes(out)


CONDITION_MAP = {
    "eq": 0x00,
    "ne": 0x01,
    "gt": 0x02,
    "ge": 0x03,
    "lt": 0x04,
    "le": 0x05,
}


def assemble(text: str) -> bytes:
    lines = text.splitlines()
    labels, instructions = _parse_assembly(lines)

    output = bytearray()
    for _, tokens in instructions:
        if not tokens:
            continue
        output.extend(_encode_instruction(tokens, labels))
    return bytes(output)


def main() -> int:
    parser = argparse.ArgumentParser(description="Assemble Another World bytecode")
    parser.add_argument("input", type=Path, help="Assembly source file")
    parser.add_argument("--output", type=Path, required=True, help="Destination bytecode binary")
    parser.add_argument("--verbose", action="store_true", help="Enable verbose logging")
    args = parser.parse_args()

    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO, format="%(levelname)s: %(message)s")

    text = args.input.read_text(encoding="utf-8")
    bytecode = assemble(text)
    args.output.write_bytes(bytecode)
    logging.info("Wrote bytecode to %s", args.output)
    return 0


if __name__ == "__main__":  # pragma: no cover - CLI entry point
    raise SystemExit(main())


